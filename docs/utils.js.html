<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>utils.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="module-svelte-router.Router.html">Router</a><ul class='methods'><li data-type='method'><a href="module-svelte-router.Router.html#back">back</a></li><li data-type='method'><a href="module-svelte-router.Router.html#forward">forward</a></li><li data-type='method'><a href="module-svelte-router.Router.html#go">go</a></li><li data-type='method'><a href="module-svelte-router.Router.html#navigationGuard">navigationGuard</a></li><li data-type='method'><a href="module-svelte-router.Router.html#onError">onError</a></li><li data-type='method'><a href="module-svelte-router.Router.html#onNavigationChanged">onNavigationChanged</a></li><li data-type='method'><a href="module-svelte-router.Router.html#push">push</a></li><li data-type='method'><a href="module-svelte-router.Router.html#replace">replace</a></li><li data-type='method'><a href="module-svelte-router.Router.html#routeURL">routeURL</a></li><li data-type='method'><a href="module-svelte-router.Router.html#start">start</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-svelte-router.html">svelte-router</a></li><li><a href="module-svelte-router_history.html">svelte-router/history</a><ul class='methods'><li data-type='method'><a href="module-svelte-router_history.html#~history">history</a></li></ul></li><li><a href="module-svelte-router_location.html">svelte-router/location</a><ul class='methods'><li data-type='method'><a href="module-svelte-router_location.html#.createLocation">createLocation</a></li></ul></li><li><a href="module-svelte-router_route.html">svelte-router/route</a><ul class='methods'><li data-type='method'><a href="module-svelte-router_route.html#.cloneRoute">cloneRoute</a></li><li data-type='method'><a href="module-svelte-router_route.html#.createRoute">createRoute</a></li><li data-type='method'><a href="module-svelte-router_route.html#.createRouteConfig">createRouteConfig</a></li><li data-type='method'><a href="module-svelte-router_route.html#.createRouteRecord">createRouteRecord</a></li></ul></li><li><a href="module-svelte-router_utils.html">svelte-router/utils</a><ul class='methods'><li data-type='method'><a href="module-svelte-router_utils.html#.deepClone">deepClone</a></li><li data-type='method'><a href="module-svelte-router_utils.html#.fullURL">fullURL</a></li><li data-type='method'><a href="module-svelte-router_utils.html#.hasPrefix">hasPrefix</a></li><li data-type='method'><a href="module-svelte-router_utils.html#.hasSuffix">hasSuffix</a></li><li data-type='method'><a href="module-svelte-router_utils.html#.historyFullURL">historyFullURL</a></li><li data-type='method'><a href="module-svelte-router_utils.html#.joinPath">joinPath</a></li><li data-type='method'><a href="module-svelte-router_utils.html#.parseURL">parseURL</a></li><li data-type='method'><a href="module-svelte-router_utils.html#.urlMatch">urlMatch</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">utils.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Svelte Router utilities module.
 * @module svelte-router/utils
 */

import tc from '@spaceavocado/type-check';

/**
 * String has suffix predicate.
 * @param {string} s tested string.
 * @param {string} suffix needle.
 * @return {boolean}
 */
export function hasSuffix(s, suffix) {
  if (tc.isNullOrUndefined(s)
    || tc.isNullOrUndefined(suffix)
    || tc.not.isString(s)
    || tc.not.isString(suffix)) {
    return false;
  }
  if (suffix.length &lt;= s.length) {
    if (s.slice(-1 * suffix.length) == suffix) {
      return true;
    }
  }
  return false;
}

/**
 * String has prefix predicate.
 * @param {string} s tested string.
 * @param {string} prefix needle.
 * @return {boolean}
 */
export function hasPrefix(s, prefix) {
  if (tc.isNullOrUndefined(s)
    || tc.isNullOrUndefined(prefix)
    || tc.not.isString(s)
    || tc.not.isString(prefix)) {
    return false;
  }
  if (prefix.length &lt;= s.length) {
    if (s.slice(0, prefix.length) == prefix) {
      return true;
    }
  }
  return false;
}

/**
 * Join URL paths.
 * @param {string} a URL path A.
 * @param {string} b URL path B.
 * @return {string}
 */
export function joinPath(a, b) {
  if (tc.isNullOrUndefined(a)
    || tc.isNullOrUndefined(b)
    || tc.not.isString(a)
    || tc.not.isString(b)) {
    return '';
  }
  const aslash = hasSuffix(a, '/');
  const bslash = hasPrefix(b, '/');
  if (aslash &amp;&amp; bslash) {
    return a + b.slice(1);
  }
  if (!aslash &amp;&amp; !bslash) {
    return a + '/' + b;
  }
  return a + b;
}

/**
 * URL match predicate
 * @param {string} a URL a.
 * @param {string} b URL b.
 * @throws an error if the URL is not valid.
 * @return {boolean}
 */
export function urlMatch(a, b) {
  if (tc.isNullOrUndefined(a) || tc.not.isString(a)
  || tc.isNullOrUndefined(b) || tc.not.isString(b)) {
    return false;
  }
  let sections = a.split('?');
  if (sections.length > 2) {
    throw new Error('invalid URL');
  }
  a = sections[0];
  sections = b.split('?');
  if (sections.length > 2) {
    throw new Error('invalid URL');
  }
  b = sections[0];

  if (hasPrefix(a, '/') == false) {
    a = `/${a}`;
  }
  if (hasSuffix(a, '/') == false) {
    a = `${a}/`;
  }
  if (hasPrefix(b, '/') == false) {
    b = `/${b}`;
  }
  if (hasSuffix(b, '/') == false) {
    b = `${b}/`;
  }

  return a == b;
}

/**
 * Parsed URL object.
 * @typedef ParsedURL
 * @property {string} base URL base.
 * @property {object} query query params.
 * @property {string} hash url hash.
 */

/**
 * Extract query param and hash from URL and return
 * the base URL, dictionary of query params, and the hash.
 * @param {string} path full URL.
 * @throws an error if the URL is not valid.
 * @return {svelte-router/utils.ParsedURL}
 */
export function parseURL(path) {
  let hash = '';
  let sections = path.split('#');

  if (sections.length > 2) {
    throw new Error('invalid URL');
  } else if (sections.length == 2) {
    path = sections[0];
    hash = sections[1];
  }
  sections = path.split('?');
  if (sections.length > 2) {
    throw new Error('invalid URL');
  }

  const result = {
    base: sections[0],
    query: {},
    hash: hash,
  };

  if (sections.length == 2) {
    const entries = sections[1].split('&amp;');
    for (const entry of entries) {
      const keyValue = entry.split('=');
      result.query[keyValue[0]] = keyValue[1];
    }
  }

  return result;
}

/**
 * Get full URL from the base URL, query object, and hash.
 * @param {string} path base URL.
 * @param {object} query query param dictionary.
 * @param {string} hash hash param.
 * @return {string}
 */
export function fullURL(path, query, hash) {
  let queryPath = '';
  if (tc.not.isNullOrUndefined(query)) {
    for (const key in query) {
      if (query.hasOwnProperty(key)) {
        if (queryPath.length > 0) {
          queryPath += '&amp;';
        }
        queryPath += `${key}=${query[key]}`;
      }
    }
    if (queryPath.length > 0) {
      path = `${path}?${queryPath}`;
    }
  }
  if (hash.length > 0) {
    path = `${path}#${hash}`;
  }
  return path;
}

/**
 * Get full URL from the history location object.
 * @param {object} location
 * @param {string} location.pathname The path of the URL.
 * @param {string} location.key A unique string representing this location.
 * @param {string} location.hash The URL hash fragment.
 * @param {string} location.search The URL query string.
 * @param {string} location.state Extra state for this location.
 * @return {string}
 */
export function historyFullURL(location) {
  return `${location.pathname}${location.search}${location.hash}`;
}

/**
 * Simple object deep clone.
 * @param {object} o source object.
 * @return {object}
 */
export function deepClone(o) {
  if (tc.isNullOrUndefined(o) || tc.not.isObject(o)) {
    return {};
  }
  return JSON.parse(JSON.stringify(o));
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Fri Aug 09 2019 23:09:15 GMT-0400 (Eastern Daylight Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
